class Solution
{
    public:
    //Function to return max value that can be put in knapsack of capacity W.
    int t[1001][1001];
    int solve(int W, int wt[], int val[], int n) 
    { 
       if(n == 0 or W == 0){
           return 0;
       }
       if(t[n][W] != -1){
           return t[n][W];
       }
       if(wt[n-1] <= W){
           return t[n][W] = max(solve(W-wt[n-1], wt, val, n-1) + val[n-1], solve(W, wt, val, n-1));
       }
       else if(wt[n-1] > W){
           return t[n][W] = solve(W, wt, val, n-1);
       }
       
    }
    int knapSack(int W, int wt[], int val[], int n) 
    { 
       // Your code here
    //   memset(t, -1, sizeof(t));
    //   int p = solve(W, wt, val, n);
    //   return p;
       for(int i=0;i<n+1;i++){
           for(int j=0;j<W+1;j++){
               if(i == 0 || j == 0){
                   t[i][j] = 0;
               }
           }
       }
       
    //   for(int i=1;i<n+1;i++){
    //       for(int j=1;j<W+1;j++){
    //           if(wt[i-1] <= j){
    //               t[i][j] = max(val[i-1]+t[i-1][j-wt[i-1]], t[i-1][j]);
    //           }
    //           if(wt[i-1] > j){
    //               t[i][j] = t[i-1][j];
    //           }
    //       }
    //   }
    for(int i=1;i<n+1;i++){
        for(int j=1;j<W+1;j++){
            if(wt[i-1] <= j){
                t[i][j] = max(val[i-1]+t[i-1][j-wt[i-1]], t[i-1][j]);
            }
            if(wt[i-1] > j){
                t[i][j] = t[i-1][j];
            }
        }
    }
       
       return t[n][W];
       
    }
};

class Solution {
public:
    
	int FindWays(int n, int m, vector<vector<int>>blocked_cells){
	    // Code here
	   // int a[n][m];
	    int m1 = 1e9+7;
	   // for(int i=0;i<n;i++){
	   //     for(int j=0;j<m;j++){
	   //         a[i][j] = 0;
	   //     }
	   // }
	   // for(auto i : blocked_cells){
	   //     int a1 = i[0];
	   //     int b1 = i[1];
	   //    // cout<<"a1"<<a1<<"  "<<"b1"<<b1<<endl;
	   //     a[a1-1][b1-1] = -1;
	   // }
	   // if(a[n-1][m-1] == -1){
	   //     return 0;
	   // }
	   //// for(int i=0;i<n;i++){
	   ////     for(int j=0;j<m;j++){
	   ////         cout<<a[i][j]<<" ";
	   ////     }
	   ////     cout<<endl;
	   //// }
	   // int dp[n][m];
	   // for(int i=0;i<n;i++){
	   //     for(int j=0;j<m;j++){
	   //         if(a[i][j] == -1){
	   //             dp[i][j] = 0;
	   //         }
	            
	   //         else if(i == 0 && j == 0){
	   //             dp[i][j] = 1;
	   //         }
	            
	   //         else{
	   //             int up, left;
	   //             if(i > 0){
	   //                 up = dp[i-1][j];
	   //             }
	   //             if(j > 0){
	   //                 left = dp[i][j-1];
	   //             }
	                
	   //             dp[i][j] = (up + left)%m1;
	   //         }
	   //     }
	   // }
	    
	   // return dp[n-1][m-1];
	   int maze[n][m];
	   int R = n;
	   int C = m;
	   for(int i=0;i<n;i++){
	        for(int j=0;j<m;j++){
	            maze[i][j] = 0;
	        }
	    }
	for(auto i : blocked_cells){
	        int a1 = i[0];
	        int b1 = i[1];
	       // cout<<"a1"<<a1<<"  "<<"b1"<<b1<<endl;
	        maze[a1-1][b1-1] = -1;
	    }
	if (maze[0][0]==-1)
        return 0;
 
    // Initializing the leftmost column
    for (int i=0; i<R; i++)
    {
        if (maze[i][0] == 0)
            maze[i][0] = 1;
 
        // If we encounter a blocked cell in leftmost
        // row, there is no way of visiting any cell
        // directly below it.
        else
            break;
    }
 
    // Similarly initialize the topmost row
    for (int i=1; i<C; i++)
    {
        if (maze[0][i] == 0)
            maze[0][i] = 1;
 
        // If we encounter a blocked cell in bottommost
        // row, there is no way of visiting any cell
        // directly below it.
        else
            break;
    }
 
    // The only difference is that if a cell is -1,
    // simply ignore it else recursively compute
    // count value maze[i][j]
    for (int i=1; i<R; i++)
    {
        for (int j=1; j<C; j++)
        {
            // If blockage is found, ignore this cell
            if (maze[i][j] == -1)
                continue;
 
            // If we can reach maze[i][j] from maze[i-1][j]
            // then increment count.
            if (maze[i-1][j] > 0)
                maze[i][j] = (maze[i][j] + maze[i-1][j]);
 
            // If we can reach maze[i][j] from maze[i][j-1]
            // then increment count.
            if (maze[i][j-1] > 0)
                maze[i][j] = (maze[i][j] + maze[i][j-1]);
        }
    }
 
    // If the final cell is blocked, output 0, otherwise
    // the answer
    return (maze[R-1][C-1] > 0)? maze[R-1][C-1]%m1 : 0;
	}
};
